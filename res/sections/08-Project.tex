%% TODO: Improve "conoscenze canoniche d'informatica" no clear, l.35
%% TODO: Replace "sottoparte" with something else, l.67
%% TODO: Crete reference for each argument with the its section
%% TODO: In the bibliography add links to the legal term pages
%% TODO: Search a definition for ``open standard``
%% TODO: Create glossary entry 'test d'unità' and replate \textit with \gls

\chapter{Il progetto di stage}
\label{cap:progetto-stage}

\section{Dalle recensione alle annotazioni}
Il compito per cui la Wonderflow viene commissionata è ricercare e riportare
statistiche di gradimento dei clienti su prodotti richiesti dai vari
committenti; siano rasoi elettrici, cellulari o altri prodotti elettronici e
non, il compito principale della Wonderflow è di ottenere queste informazioni.

Le preziosi fonti, dove l'azienda attinge, sono le recensioni dei prodotti
degli utenti nei più grandi servizi di vendita online (es. Amazon), in cui è
subito disponibile un loro cospicuo numero senza limiti e costi aggiunti
rendendo davvero semplice l'operazione di raccolta dati. La recensione
però è un'informazione grezza, non immediatamente utilizzabile per le seguenti
ragioni:
\begin{itemize}
\item E' in forma di testo libero
\item Contiene all'interno informazioni su più aspetti del prodotto
\item Spesso la descrizione non è chiara, a volte contraddittoria
\item Può essere scritta in più lingue
\end{itemize}

tutto ciò dovuto all'autore della recensione: l'umano. \\

A fronte di questo, la Wonderflow ha progettato un processo di raffinamento
(fig. \ref{fig:review_process}) per poter usufruire delle informazioni
all'interno delle recensioni, ed è proprio qui che entra in gioco in modo
preponderante la figura dell'\textbf{analista}.

\subsection{Descrizione del processo}
\label{subsec:processo_recensioni_annotazioni}
L'intera catena è divisa in 5 parti:
\begin{enumerate}
  \item Download recensioni (\textit{Developer})
  \item Distribuzione recensione agli analisti (\textit{Operations Manager})
  \item Analisi (\textit{Analysts})
  \item Controllo qualità (\textit{Senior Analyst})
  \item Archiviazione annotazioni approvate (\textit{Developer})
\end{enumerate}

\begin{figure}[ht]
\begin{center}
\includegraphics[height=2cm]{review_process}
\caption{Rappresentazione del processo da recensione ad annotazioni}
\label{fig:review_process}
\end{center}
\end{figure}

La primo trattato consiste nel \textit{download} delle recensioni da parte di
un dipendente, solitamente uno sviluppatore. Il motivo è che la procedura
richiede l'avvio di una serie di \gls{script} e controlli fuori dalle
competenze di personale con conoscenze canoniche d'informatica.
Una volta scaricate le recensioni dai vari siti web di vendita online, esse
vengono passate all'\textit{Operations Manager} in modo che possa distribuirle
tra i vari \textbf{analisti} in base alla disponibilità e alle abilità.

Una volta che l'analista ha a disposizione le recensioni da analizzare può
iniziare a cercare le \textbf{annotazioni}. Come detto precedentemente le
annotazioni sono testo in cui si può dedurre un \textbf{sentimento} su un
aspetto del prodotto.

Essendo che in una recensione l'autore può aver dato più commenti sulle varie
caratteristiche dell'articolo ci si aspetta di avere un'annotazione, o più, per
ogni commento. E' da precisare che il testo dell'annotazione non coincide quasi
mai con il testo del commento ma è ben si una sua sottoparte che possa
rappresentarlo al meglio.

La procedura per individuare annotazioni viene eseguita in un tool interno
chiamato \textbf{Admin Wonderflow} dove, tra i tanti servizi offerti, vi è
l'\textbf{editor} di selezione delle annotazioni. L'analista, una volta aperto
l'editor, è in grado di selezionare la recensione, visualizzarne il contenuto ed
iniziare l'analisi. Per creare un'annotazione inseribile nel sistema
informatico aziendale, l'analista deve necessariamente seguire la seguente
serie di passaggi:

\paragraph{Evidenziarla}
\label{evidenziarla}
L'analista, con il cursore del mouse, evidenzia la frazione di testo della
recensione dove ha individuato il commento.

\paragraph{Riassumerla}
\label{riassumerla}
L'analista deve riassumere il testo sottolineato individuando un periodo che
meglio rappresenti il commento. Nel caso l'annotazione fosse espressa in una
lingua diversa dall'inglese è necessario che l'analista fornisca sia la
traduzione che il testo originale.

\paragraph{Assegnargli un sentimento}
\label{sentimento}
E' compito dell'analista decidere se quell'annotazione ha un significato
\textbf{positivo} oppure \textbf{negativo}.

\paragraph{Catalogarla}
\label{catalogarla}
Le categorie nascono per raggruppare tutte quelle annotazioni che si
riferiscono ad una stessa caratteristica di un prodotto. L'analista deve
associare per ogni annotazione una delle categorie offerte dall'editor.

\paragraph{Intitolarla}
\label{intitolarla}
È richiesto che l'analista dia un titolo all'annotazione.

\paragraph{Salvarla}
\label{salvarla}
L'analista dichiara di aver terminato l'analisi di una recensione e sottomette
le annotazioni prodotte al controllo qualità. \\

Durante questa procedura verrà generata una struttura dati in formato \gls{JSON}
al cui interno vi è un attributo contenente la lista delle annotazioni. Ogni
annotazione viene salvata con il seguente schema (NdR: per motivi di leggibilità
riporto solo il nome ed il tipo di ogni attributo):

\begin{center}
\begin{lstlisting}[frame=single]
{
  "category": "string",
  "name": "string",
  "text" : "string",
  "syn" : "string",
  "sentiment" : "number",
  "start" : "number",
  "offset" : "number",
  "uid" : "string",
  "version" : "string",
  "origin" : "string",
  "id" : "string"
}
\end{lstlisting}
\end{center}

La tabella sottostante descrive il significato di ogni campo, il suo utilizzo e
in quale fase viene prodotto.

\begin{center}
\begin{longtable}{|>{\centering}p{2.2cm}|p{8cm}|>{\centering}p{2.5cm}|}
\hline
\textbf{Attributo} & \textbf{Descrizione} & \textbf{Fase} \tabularnewline \hline
\textit{category} &
Categoria di appartenenza di un'annotazione. Permette di capire su quale
aspetto di un prodotto l'annotazione offre un giudizio. &
\nameref{catalogarla} \tabularnewline \hline
\textit{name} &
Testo dell'annotazione e traduzione in inglese nel caso il testo originale
fosse espresso in un'altra lingua. Rappresenta l'annotazione vera e propria. &
\nameref{riassumerla} \tabularnewline \hline
\textit{text} &
Testo del commento evidenziato dall'analista. Il salvataggio del commento
risolve l'esigenza, soprattutto in fase di controllo sulla qualità, di avere il
contesto di dove l'annotazione è stata presa e quindi di poter dedurre se questa
è pertinente oppure no. &
\nameref{evidenziarla} \tabularnewline \hline
\textit{syn} &
Traduzione in lingua originale dell'annotazione. Nei sviluppi futuri potrà
essere usato per garantire l'identificazione di una medesima annotazione in
diverse lingue. &
\nameref{riassumerla} \tabularnewline \hline
\textit{sentiment} &
Il sentimento espresso dall'annotazione. Il sentimento positivo viene
rappresentato con l'intero 1, mentre il sentimento negativo con l'intero 0. &
\nameref{sentimento} \tabularnewline \hline
\textit{start} ed \textit{offset} &
Posizione di partenza del testo dell'annotazione e la sua lunghezza. &
\nameref{evidenziarla} \tabularnewline \hline
\textit{uid} &
Titolo dell'annotazione. &
\nameref{intitolarla} \tabularnewline \hline
\textit{version} &
Versione dell'annotazione. Disambigua le annotazioni prodotto dopo una
aggiornamento consistente sulla gestione delle annotazioni. Viene inizializzato
automaticamente con il valore ``v2'' dall'editor. &
\nameref{salvarla} \tabularnewline\hline
\textit{origin} &
Settore della recensione dov'è stata individuata l'annotazione all'interno della
recensione. I possibili valori sono:
\begin{itemize}
\item ``free-text''
\item ``pros''
\item ``cons''
\end{itemize}
nel caso l'annotazione fosse stata presa rispettivamente nel testo libero, nei
pregi oppure nei difetti &
\nameref{evidenziarla} \tabularnewline \hline
\caption{Descrizione attributi di un'annotazione in JSON con la relativa fase}
\label{tab:attributi_annotazione}
\end{longtable}
\end{center}

Una volta che l'annotazione è stata revisionata dal \textit{Senior Analyst},
risultando positiva ai test sulla qualità, può essere archiviata ed elaborata
dal sistema per poter fornire dati alla \textbf{Wonderboard}. È doveroso
aggiungere una nota: l'oggetto salvato nell'archivio è la rappresentazione
della recensione al cui interno sono presenti le annotazioni; di tutta la serie
di campi che compongono l'oggetto solo una piccola parte verrà trattata durante
la relazione.

\subsection{Errori nel processo d'analisi}
Il processo d'analisi delle recensioni è di primaria importanza in quanto
fornisce i dati necessari per offrire i servizi proposti dall'azienda.
Tuttavia per poterlo eseguire, si è costretti a richiedere continuamente
l'intervento di operatori umani data la natura non automatizzabile delle
operazioni che si vanno a compiere.

Ne consegue che il sistema perde la scalabilità, aumenta i costi di mantenimento
ma soprattutto è necessaria un'attenta e costante supervisione del lavoro svolto
dagli analisti che può facilmente essere soggetto ad errori.

Durante il periodo dello stage è stato possibile comprendere i principali
fattori che conducono l'analista a commettere sbagli durante l'analisi delle
recensioni (i risultati sono riportati nella tabella \ref{tab:fattori_errore}).

\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|p{10cm}|}
\hline
\textbf{Fattore} & \textbf{Conseguenza} \\ \hline
Inesperienza &
L'analista non comprende a pieno la recensione creando annotazioni di poca
utilità. È inoltre possibile che non comprenda a pieno quali siano le
caratteristiche per produrre una buona annotazione, sfociando in risultati
scadenti. \\ \hline
Carico di lavoro &
L'analista, dove un certo numero di ore di lavoro, tende a perdere la
concentrazione aumentando la possibilità di commettere errori. \\ \hline
Tempistiche &
A volte l'analisi delle recensioni devono essere svolte in tempi più stretti.
Questo porta l'analista a svolgere un lavoro frettoloso.
\\ \hline
\end{tabular}
\end{center}
\caption{Fattori d'errore durante l'analisi delle recensioni}
\label{tab:fattori_errore}
\end{table}

\section{Le componenti sviluppate}
Ora che è stato introdotto il quadro generale per l'estrapolazione delle
annotazioni dentro le recensioni, è possibile parlare dell'obiettivo dello stage
tenuto presso la Wonderflow. Come è stato detto un grosso problema è l'analisi
delle recensioni tenuta dall'analista, la quale sovente commette una serie
d'errori che deficitano la produttività dell'azienda.

In questa sezione verranno esposi le varie componenti sviluppate nel corso dello
stage al fine di ridurre gli errori e garantendo un miglioramento dell'efficacia
nel processo di analisi delle recensioni.

\subsection{Il modulo NER}
Il progetto di stage mira al miglioramento del lavoro dell'analista introducendo
un supporto nell'individuazione delle possibile annotazioni. Più precisamente
si tratta di un modulo \gls{NER} grafico il quale individua nelle recensioni
annotazioni basandosi su quelle precedentemente archiviate.

Il suo uso è molto semplice: all'analista, entrando nell'editor, gli vengono
immediatamente suggerite delle possibili annotazioni nello stesso formato di
quelle individuate. Questo significa che l'analista si troverà nelle recensioni
le annotazioni già evidenziate e i campi dati richiesti già inseriti.

Ora sta all'analista decidere di scegliere se accettarle o meno, in quanto è
possibile che all'interno di quella recensione l'annotazione suggerita non sia
corretta. Nel caso l'accettasse, l'annotazione si inserirebbe nella lista di
quelle da validare; in caso non l'accettasse verrebbe semplicemente rimossa
dall'editor.

Per capire meglio la sua utilità è comodo paragonarlo ad uno strumento presente
da molto tempo nei sistemi di messaggistica per cellulari, quando l'utente è
intento a comporre le parole: il correttore. Mentre scrive la parola,
all'utente gli vengono visualizzate delle possibili scelte che può usare.
Selezionando la scelta desiderata si vedrà la porzione di parola scritta essere
sostituita con la parola suggerita. Questo ancora oggi è uno strumento di
notevole aiuto che aiuta a velocizzare la scrittura dei messaggi e, in modo
intrinseco, ad evitare di commettere errori di battitura.

Analogamente per le annotazioni, ora l'analista non deve più seguire tutti i
passaggi che portano alla creazione delle annotazioni (descritto nella
sottosezione \ref{subsec:processo_recensioni_annotazioni}), ma è sufficiente
confermare il suggerimento dato dal sistema \gls{NER}. Oltre a risparmiare
tempo, esattamente come il correttore automatico, si evitano tutti possibili
errori che si possono incorrere in questa fase per i fattori esposti nella
tabella \ref{tab:fattori_errore}. Inoltre, in fase di controllo della qualità le
annotazioni create attraverso il sistema di riconoscimento vengono approvate
automaticamente essendo prese d'annotazioni precedentemente controllate;
riducendo anche il tempo del \textit{Senior Analyst} per il controllo qualità.

Nella sezione xx verrà discussa tutta la parte di sviluppo e funzionamento.

\subsection{Moderazione del glossario}
Con il termine \textit{glossario} definisco il sottoinsieme dell'archivio
delle annotazioni individuabile all'interno delle recensioni. La motivazione del
perché sola una determinata parte dell'archivio è rintracciabile, e non tutto
l'insieme a disposizione, è la possibilità di raggiungere un certo livello di
qualità nel riconoscimento. Il livello di qualità viene misurato attraverso due
indici: la \textit{precision} e la \textit{recall}.

Le due misure vanno ad indicare rispettivamente quante annotazioni, di quelle
suggerite, sono corrette rispetto al contesto della recensione; quante
annotazioni sono state suggerite all'interno della recensione, sul totale
possibile. Entrambe sono unità adimensionali con valore compreso tra 0 ed 1.

Il glossario deve essere scelto attentamente in modo da ottenere buoni livelli
di \textit{recall} e \textit{precision}. È chiaro che l'uso di dizionari ampi
favorirebbe il valore di \textit{recall}, avendo a disposizione una vasta scelta
d'annotazioni, ma potrebbe portare ad un'abbassamento del valore di
\textit{precision} in quanto presenti annotazioni ambigue.

È bene ricordarsi che le annotazioni derivano da frasi scritte dagli utenti
perciò selezionare annotazioni con testi semplici, corti e generici aumentano
la possibilità di individuazione. Difficilmente annotazioni con testi lunghi,
complessi, specifici su un argomento verrebbero riproposti in future recensioni.

Anche l'inserimento di nuove annotazioni nel glossario deve essere monitorato
per non introdurre elementi che non migliorino, o addirittura peggiorino, la
qualità del riconoscimento.

Tutte queste esigenze sono state tradotte nello sviluppo di un semplice sistema
di moderazione che comprende: un'interfaccia grafica per selezionare le
annotazioni che verranno inserite nel glossario e di uno \gls{script} di
misurazione degli indici di \textit{precision} e \textit{recall}.

Per la consultazione completa delle due parti si guardi: sezione xx e sezione
xx.

\section{Altri compiti}
La realizzazione del sistema di riconoscimento automatico era il principale
obiettivo della Wonderflow. Tuttavia, il programma di stage comprendeva anche lo
svolgimento di una serie d'incarichi atti a migliorare lo sviluppo del software.

\subsection{Script per esportare annotazioni}
Molto usato per produrre ambienti di test è stato lo \gls{script} di
esportazione delle annotazioni.

Lo \gls{script} ha il compito di esportare le annotazioni salvate all'interno
delle recensioni nella fase di creazione dell'annotazione, separarle, adattarle
e salvarle in un archivio a parte.

In questo modo è sempre possibile attingere all'archivio principale senza
bisogno di richiede la costruzione di altri piccoli archivi. Inoltre, la scelta
delle recensioni da usare come fonte può avvenire tramite query rendendo molto
semplice creare vari archivi di annotazioni con le proprie caratteristiche. Ciò
risulta utile in fase di test dove si posso scegliere diversi input con cui
effettuare la prova.

Il trattazione completa è trattate nella sezione xx.

\subsection{Generatore di componenti web}
La strumentazione software della Wonderflow è sviluppata principalmente come
applicazione web. Usando il framework AngularJS, il quale spinge a seguire lo
sviluppo per componenti, l'azienda produce una moltitudine di moduli dove
vengono esportati singolo componenti e successivamente messe insieme nei vari
progetti. I vantaggi di questo approccio sono il rispetto del
\gls{separation_of_concerns}, basso accoppiamento tra le componenti,
formazione di piccole parti semplici da mantenere e facili da testare.

Tuttavia ogni volta che si crea un nuovo modulo è necessario ripetere le
procedure d'inizializzazione, in modo da allinearlo con le regole aziendali,
implicando un relativo consumo di tempo.

Per evitare ciò si è deciso di realizzare un programma che generi l'ambiente di
lavoro dove avviare lo sviluppo del componente, azzerando i tempi di
configurazione.

\subsection{Refactoring del BaaS}
I concetti di \gls{front-end}, \gls{back-end} e \gls{web-service} sono molto
importanti che stanno dando vita ad nuovo filone di sviluppo del software.
La Wonderflow gli ha integrati all'interno del panorama aziendale, sviluppando
quello che in gergo tecnico si definisce un \gls{BaaS}. Attraverso
di esso lo sviluppo di applicazione web si limita alla creazione del mero
\gls{front-end} e l'uso delle \gls{API} fornite dal \gls{BaaS} per effettuare
le operazioni sui dati richieste.

Malgrado le cure e le attenzioni poste, stretti vincoli sul tempo hanno portato
all'uso di metodologie errate durante lo sviluppo del \gls{BaaS} che ora si
manifestano con un'alto accoppiamento delle sue componenti e l'impossibilità
di riutilizzare parte del suo codice in altre applicazioni.

Per risolvere la situazione è stato pianificato un \gls{refactoring} che mira
a deframmentarlo in parti indipendenti che cooperano tra loro attraverso
sani principi d'inclusione.

\section{Tecnologie utilizzate}
Data il progetto ad ampio raggio sono state usate una buon numero di tecnologie
che hanno alzato di molto il valore dell'esperienza.

\subsection{AngularJS}
La ribalta di JavaScript negli ultimi anni ha permesso la formazione di
nuovi modi per creare applicazioni web. Non più con l'incubo del blocco
dell'esecuzione del codice sui browser, è stata marcata una linea molto più
netta tra client e server: tutta la logica di rappresentazione della pagina web
viene spostata direttamente sul primo, mentre nel secondo persistono tutti
gli algoritmi che concernano i dati. Questo ha fatto si che le
\gls{dynamic-web-page} fossero sostituite dalle più moderne
\gls{single-page-application}, molto più simile alle applicazioni desktop,
portando non solo a pagine molto più reattive ma a tracciare un sentiero guida
per gli sviluppatori che gli conducessero all'adozione di sani principi di
progettazione software.

Uno dei framework di maggior successo nel campo delle
\gls{single-page-application} è sicuramente \textit{AngularJS}. Diventato un
punto di riferimento per la formazione di siti web, \textit{AngularJS} porta
con se tutta una serie di supporti e metodologie atti a produrre un codice molto
leggibile, semplice e ben diviso in varie componenti. Proprio attraverso le
\textbf{componenti}, \textit{AngularJS} insegna che dividere varie parti della
pagina in oggetti autonomi e riusabili ripaga nel tempo. Di fatto, la struttura
di un progetto \textit{AngularJS} va quasi a premiare gli sforzi dello
sviluppatore che seguendo i consigli impartiti può beneficiare di tutta una
serie di agevolazioni che il framework propone.

\begin{figure}[H]
\begin{center}
\includegraphics[height=1.6cm]{angularjs}
\caption{Logo AngularJS}
\label{fig:angularjs_logo}
\end{center}
\end{figure}

\subsection{Docker}
\textit{Docker} è un programma che permette la creazione di \textbf{container}
dove eseguire pezzi di software. I container sono un'astrazione del sistema
operativo dove viene caricato il software e tutte le dipendenze necessarie per
eseguirlo. La particolarità che ha reso famoso \textit{Docker} rispetto alle
tradizionali \glspl{macchina-virtuale} è la gestione più intelligente
dell'infrastruttura alla base del sistema operativo, garantendo ai vari
container di essere isolati, aumentando cosi la sicurezza, e di condividere le
librerie di uso comune, diminuendo cosi l'uso di \acrshort{RAM}.
\begin{figure}[H]
\begin{center}
\includegraphics[height=4cm]{docker}
\caption{Logo Docker}
\label{fig:docker_logo}
\end{center}
\end{figure}

\subsection{Git}
In un qualsiasi progetto software bisogna sempre tenere in considerazione la non
linearità dello sviluppo: codice già scritto può venir modificato; il team di
sviluppo può decidere di separarsi per realizzare parti distinte; soluzioni
diverse ad un problema possono venir realizzate e comparate per decidere quale
sia la più idonea a risolverlo. In tutti i casi è necessario poter tener traccia
dello sviluppo del progetto in modo da aver un maggior controllo su di esso.

Questo è quello che fa \textit{Git}; un \gls{CVS} progettato per piccoli o
grandi progetti, veloce e semplice da usare.

\begin{figure}[H]
\begin{center}
\includegraphics[height=1.4cm]{git}
\caption{Logo Git}
\label{fig:git_logo}
\end{center}
\end{figure}

\subsection{LingPipe in Java}
\textit{LingPipe} è un \textit{tool kit} per esaminare testi usando la
\gls{linguistica-computazionale}. L'architettura su cui si basa garantisce
efficienza, scalabilità, riusabilità e robustezza promuovendolo come valido
prodotto per l'analisi testuale. \textit{LingPipe} è utilizzabile solamente
attraverso il linguaggio \textit{Java}.

\begin{figure}[H]
\begin{center}
\includegraphics[height=3cm]{java}
\caption{Logo Java}
\label{fig:java_logo}
\end{center}
\end{figure}

\subsection{MongoDB}
Oramai diventato uno dei più famosi \gls{DBMS} non relazionali, MongoDB viene
usato da molte aziende per la velocità e facilità con cui vengono gestite i
dati archiviati. Per la precisione è un \gls{DBMS} orientato al
\textbf{documento} che si discosta dalle tradizionali tabelle in favore di un
contenuto non uniforme, permettendo di rappresentare entità più complesse.

Il maggior punto di forza di MongoDB è l'uso di una derivazione dello schema
\gls{JSON} per salvare i dati, la quale rende davvero semplice create modelli di
oggetti per l'applicazioni JavaScript e interagirvi tramite un \gls{DAO}.

\begin{figure}[H]
\begin{center}
\includegraphics[height=1.5cm]{mongodb}
\caption{Logo MongoDB}
\label{fig:mongodb_logo}
\end{center}
\end{figure}

\subsection{Node.js}
Una buona parte della popolarità di JavaScript è sicuramente merito dell'enorme
diffusione che ha avuto \textit{Node.js}\footnote{\textit{Node.js} is a
trademark of Joyent, Inc. and is used with its permission. We are not endorsed
by or affiliated with Joyent.}. Grazie a questo interprete è possibile eseguire
programmi JavaScript direttamente dal calcolatore, senza dover passare per il
browser con tutte le restrizioni imposte. Forte del suo modello
\gls{event-driven}, con chiamate \textit{I/O} non bloccanti, \textit{Node.js}
ha acquisito sempre più consensi nella comunità di sviluppatori web ma non solo.
Grazie alla libertà concessa dal linguaggio JavaScript e le alte prestazioni
raggiunte da \textit{Node.js}, un numero sempre maggiore di applicazioni desktop
vengono realizzate, senza che esse abbiano alcun legame con il mondo del web.

\begin{figure}[H]
\begin{center}
\includegraphics[height=2.3cm]{nodejs}
\caption{Logo Node.js}
\label{fig:nodejs_logo}
\end{center}
\end{figure}

\subsection{npm (Node Package Manager)}
\begin{quote}
\textit{Write programs that do one thing and do it well. Write programs to work
together. [...]}\footnote{Scrivere programmi che fanno una cosa e la facciano
bene. Scrivere programmi che lavorino insieme.}
\end{quote}

La frase d'apertura è parte del riassunto di Doug McIlroy riguardante
\textit{``Filosofia Unix''}, filosofia che promuove i concetti di
\textbf{modularità} e \textbf{riusabilità} nello sviluppo del software. Questi
due concetti insieme alla \textbf{condivisione}, formano i principi su cui si
basa il progetto \textit{npm}, gestione di quelli che vengono chiamati
\textbf{pacchetti} \textit{Node.js}. In breve, ogni pacchetto è un programma
autonomo che adempie al suo \gls{contratto} in modo da poter cooperare, con
altri pacchetti, all'interno di un sistema software più ampio.

Unendo la caratteristica \textit{open source} del progetto alla semplicità con
cui vengono gestiti i pacchetti \textit{Node.js}, \textit{npm} è diventato in
brevissimo tempo l'ecosistema di librerie \textit{open source} più grande al
mondo.

Dato che però le aziende private non sempre si sposano bene con la filosofia di
condivisione libera delle proprie proprietà, \textit{npm} metta a disposizione
la possibilità di create ``organizzazioni'' dove poter pubblicare i pacchetti
\textit{Node.js} in modo che solo gli utenti facentene parte possano
visualizzarli.

\begin{figure}[H]
\begin{center}
\includegraphics[height=1.2cm]{npm}
\caption{Logo npm}
\label{fig:npm_logo}
\end{center}
\end{figure}

\subsection{Protractor}
\textit{Protractor} è un \textit{\gls{E2ET} framework} per applicazioni
\textit{AngularJS}. I \textit{test d'unità} sono una prima difesa contro i
possibili errori presenti nel codice. Tuttavia la maggior parte dei
\textit{fault} avvengo quando più componenti interagiscono fra loro.
In quel caso è necessario usare un secondo livello di test: gli \gls{E2ET}.
\textit{Protractor} compie il suo obiettivo fornendo sia un'ambiente di test
controllato, ad ogni esecuzione dei test viene eseguita l'istanza di un browser
per simulare l'interazione dell'utente sulla pagina web; che di un ampio insieme
di \gls{API} per fornire:
\begin{itemize}
\item controllo sull'utente virtuale
\item analisi sullo stato della pagina web
\end{itemize}
garantendo copertura totale su ogni aspetto dell'applicazione.

\begin{figure}[H]
\begin{center}
\includegraphics[height=1.5cm]{protractor}
\caption{Logo Protractor}
\label{fig:protractor_logo}
\end{center}
\end{figure}
